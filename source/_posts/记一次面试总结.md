---
title: 记一次面试总结
date: 2018-04-22 13:28:12
tags:
    - 面试
    - js
copyright:
    - js
---
#### 一、vue的keep-alive组件
`<keep-alive>`是`Vue`的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染`DOM`.
> `<keep-alive> `包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 `<transition>` 相似，`<keep-alive>` 是一个抽象组件：它自身不会渲染一个` DOM `元素，也不会出现在父组件链中.

对应的属性有:
> include: 字符串或正则表达式。只有匹配的组件会被缓存。
> exclude: 字符串或正则表达式。任何匹配的组件都不会被缓存。

常见用法有:

```
<keep-alive include="test-keep-alive">
  <!-- 将缓存name为test-keep-alive的组件 -->
  <component></component>
</keep-alive>
<keep-alive include="a,b">
  <!-- 将缓存name为a或者b的组件，结合动态组件使用 -->
  <component :is="view"></component>
</keep-alive>

<!-- 使用正则表达式，需使用v-bind -->
<keep-alive :include="/a|b/">
  <component :is="view"></component>
</keep-alive>

<!-- 动态判断 -->
<keep-alive :include="includedComponents">
  <router-view></router-view>
</keep-alive>

<keep-alive exclude="test-keep-alive">
  <!-- 将不缓存name为test-keep-alive的组件 -->
  <component></component>
</keep-alive>
```

`keep-alive`生命周期钩子函数：`activated、deactivated`
使用`<keep-alive>`会将数据保留在内存中，如果要在每次进入页面的时候获取最新的数据，需要在`activated`阶段获取数据，承担原来`created`钩子中获取数据的任务。
结合router，缓存部分页面.
使用`$route.meta`的`keepAlive`属性：

```
<keep-alive>
    <router-view v-if="$route.meta.keepAlive"></router-view>
</keep-alive>
<router-view v-if="!$route.meta.keepAlive"></router-view>
```

需要在`router`中设置`router`的元信息`meta`：

```
//...router.js
export default new Router({
  routes: [
    {
      path: '/',
      name: 'Hello',
      component: Hello,
      meta: {
        keepAlive: false // 不需要缓存
      }
    },
    {
      path: '/page1',
      name: 'Page1',
      component: Page1,
      meta: {
        keepAlive: true // 需要被缓存
      }
    }
  ]
})
```

#### 二、关于web前端性能优化
###### 1. 减少 HTTP请求数
> 一个完整的请求都需要经过 DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个 “漫长” 而复杂的过程。时间成本就是用户需要看到或者 “感受” 到这个资源是必须要等待这个过程结束的，资源上由于每个请求都需要携带数据，因此每个请求都需要占用带宽.

减少 HTTP请求数的主要途径包括：
(1). 从设计实现层面简化页面;
(2). 合理设置 HTTP缓存,缓存的力量是强大的，恰当的缓存设置可以大大的减少 HTTP请求;
(3). 资源合并与压缩,尽可能的将外部的脚本、样式进行合并，多个合为一个。另外， CSS、 Javascript、Image 都可以用相应的工具进行压缩，压缩后往往能省下不少空间;
(4). CSS Sprites,合并 CSS图片，减少请求数的又一个好办法;
(5). Inline Images,使用 data: URL scheme的方式将图片嵌入到页面或 CSS中，如果不考虑资源管理上的问题的话，不失为一个好办法;
(6). Lazy Load Images（图片懒加载）这条策略实际上并不一定能减少 HTTP请求数，但是却能在某些条件下或者页面刚加载时减少 HTTP请求数;
###### 2. 将外部脚本置底（将脚本内容在页面信息内容加载后再加载）
###### 3. 避免重复的资源请求
这种情况主要是由于疏忽或页面由多个模块拼接而成，然后每个模块中请求了同样的资源时，会导致资源的重复请求.
###### 4. Image压缩
###### 5. 字符串拼接
在 `Javascript中`使用`"+" `号来拼接字符串效率是比较低的，因为每次运行都会开辟新的内存并生成新的字符串变量，然后将拼接结果赋值给新变量。与之相比更为高效的做法是使用数组的` join`方法，即将需要拼接的字符串放在数组中最后调用其 `join`方法得到结果。不过由于使用数组也有一定的开销，因此当需要拼接的字符串较多的时候可以考虑用此方法。
#### 三、vue-router的按需加载
以前可以通过`webpack`里面的`require.ensure`，这样做会将单独拉出来作为一个`chunk`文件:
```
const Login = r => require.ensure( [], () => r (require('../component/Login.vue')));
```

现在`Vue-router`的官网推荐如下方式：
```
//vue异步组件和webpack的【代码分块点】功能结合，实现了按需加载
const App = () => import('../component/Login.vue');
```

但是在很多情况下，这么写npm控制台直接报错:
```
Module build failed: SyntaxError: Unexpected token
```

原来是`import`这儿报错了，这就需要`babel`的插件了，`vue-router`官网上有一段提示：
> 如果您使用的是` Babel`，你将需要添加` syntax-dynamic-import `插件，才能使` Babel `可以正确地解析语法。

至此，问题全部解决了。
如果使用`vue-cli`生成项目，很可能在`babel-loader`没有配置上面的插件，这时需要我们自己去安装此插件：
```
cnpm install babel-plugin-syntax-dymic-import --save-dev
```

然后修改`js`的`loader`部分：

```
{
    test: /\.js$/,
    loader:'babel-loader',
    options:{
        plugins:['syntax-dynamic-import']
    }
}
```

增加了`option`选项，至此，能识别我们`const App = () => import('../component/Login.vue')`;的语法了.
在打包的时候，发现我们如果只是这么写：`const App = () => import('../component/Login.vue')`;出现的`chunk`包名字都是乱的，如果我们指定命名，该怎么办呢？`webpack3`提供了`Magic Comments`（魔法注释）

```
const App = () => import(/* webpackChunkName:'login'*/ '../component/Login.vue');
```

这样我们就为打包出来的`chunk`指定一个名字，最终生成`login.js`的`chunk`包.

#### 四、import和require的不同

|加载方式|规范|命令|特点|
|:-------:|:-------:|:-------|-------:|
|运行时加载|CommonJS/AMD|require|社区方案，提供了服务器/浏览器的模块加载方案。非语言层面的标准。只能在运行时确定模块的依赖关系及输入/输出的变量，无法进行静态优化。|
|编译时加载|ESMAScript6+|import|语言规格层面支持模块功能。支持编译时静态分析，便于JS引入宏和类型检验。动态绑定。|

#### 五、vue中computed 和 watch的不同
①从属性名上，computed是计算属性，也就是依赖其它的属性计算所得出最后的值。watch是去监听一个值的变化，然后执行相对应的函数。
②从实现上，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算。watch在每次监听的值变化时，都会执行回调。其实从这一点来看，都是在依赖的值变化之后，去执行回调。很多功能本来就很多属性都可以用，只不过有更适合的。如果一个值依赖多个属性（多对一），用computed肯定是更加方便的。如果一个值变化后会引起一系列操作，或者一个值变化会引起一系列值的变化（一对多），用watch更加方便一些。
③watch的回调里面会传入监听属性的新旧值，通过这两个值可以做一些特定的操作。computed通常就是简单的计算。
④watch和computed并没有哪个更底层，watch内部调用的是vm.$watch，它们的共同之处就是每个定义的属性都单独建立了一个Watcher对象。
#### 六、关于js的内存泄露的问题
> `javascript`具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中的使用的内存。而在`C`和`C++`之类的语言中，开发人员的一项基本任务就是手动跟踪内存的使用情况，这是造成许多问题的一个根源。在编写`javascript`程序时候，开发人员不用再关心内存使用的问题，所需内存的分配 以及无用的回收完全实现了自动管理。

`JavaScript`中最常用的垃圾收集方式是标记清除(`mark-and-sweep`)。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占的内存，因为只要执行流进入相应的环境，就可能用到它们。而当变量离开环境时，这将其 标记为“离开环境”。

> 虽然`JavaScript`会自动垃圾收集，但是如果我们的代码写法不当，会让变量一直处于“进入环境”的状态，无法被回收。下面列一下内存泄露常见的几种情况。

常见内存泄漏的原因有:
1.全局变量引起的内存泄漏
```
function leaks(){  
    leak = 'xxxxxx';//leak 成为一个全局变量，不会被回收
}
```
2.闭包引起的内存泄漏
```
var leaks = (function(){  
    var leak = 'xxxxxx';// 被闭包所引用，不会被回收
    return function(){
        console.log(leak);
    }
})()
```
3.dom清空或删除时，事件未清除导致的内存泄漏
```
<div id="container">  
</div>

$('#container').bind('click', function(){
    console.log('click');
}).remove();
```
> `zepto `和原生` js`下，`#container dom `元素还在内存里,`jquery `的 `empty`和` remove`会帮助开发者避免这个问题

```
<div id="container">  
</div>

$('#container').bind('click', function(){
    console.log('click');
}).off('click').remove();
//把事件清除了，即可从内存中移除
```

4.子元素存在引用引起的内存泄漏
![内存泄露](http://img0.ph.126.net/h1lUsqUBF3xbcyfMgvphhQ==/6632731326793525914.gif)
* 黄色是指直接被 `js`变量所引用，在内存里;
* 红色是指间接被 `js`变量所引用，如上图，`refB` 被` refA `间接引用，导致即使` refB` 变量被清空，也是不会被回收的;
* 子元素` refB `由于` parentNode` 的间接引用，只要它不被删除，它所有的父元素（图中红色部分）都不会被删除;
#### 七、箭头函数this和普通函数的this区别
普通函数中的this：
1.默认情况下（非严格模式），没有找到直接调用者，this指向window;
2.严格模式（'use strict'），没有找到直接调用者，this是undefined;
3.this总是代表它的直接调用者，比如：obj.fun，那么fun中的this是obj;
4.使用call，apply，bind绑定的this指向的是绑定的对象;
箭头函数中的this:
1.箭头函数作为函数的一种形式,对于this的处理和普通函数有所区别,其没有自己的this上下文,也就是说通过bind/call/apply函数方法设置this值时无效的，会被忽略;
2.因为箭头函数没有自己的this上下文，那么当它作为对象的方法函数运行时，this并不指向这个对象;
3.箭头函数的的函数体中出现的this在运行时绑定到最近的作用域上下文对象;
4.你可以认为箭头函数的this和调用者无关，只和其定义时所在的上下文相关;