---
title: 2018前端经典面试题
date: 2018-04-14 17:21:15
tags:
    - 面试题
copyright:
    - js
---

#### 一、关于事件循环，以下代码将输出什么？
看下面的代码，输出的结果是什么？并解释你的答案。
```
function printing() {
    
    console.log(1);

    setTimeout(function() {
        console.log(2);
    }, 1000);

    setTimeout(function() {
        console.log(3);
    }, 0);

    console.log(4);
}

printing();
```
答案是:
```
1
4
3
2
```
原因是:
> 首先js事件的处理机制是:是单线程+事件队列,事件队列任务执行的条件是:1,主线程已空闲;2,满足任务触发条件:定时函数(延时时间已到达);事件函数(特定事件被触发);ajax的回调函数服务端已有数据相应.因此，当调用 setTimeout() 函数时，即使延迟的时间被设置为0，提供的回调也会被放入事件队列中，直到主线程空闲并且指定的时间用完后，它才开始执行动作。

#### 二、如何理解和应用JavaScript闭包?
> 关于闭包概念很多人觉得很抽象，可以理解闭包是一种使函数能够取到其它函数的局部变量的语法机制。
例如:
```
function outFunc(){

    var name = "javascript";

    function inFunc(){

        console.log(name);

    }

    return inFunc;

}
let inFunc = outFunc();
inFunc(); //控制台显示"javascript"
```
> 在这个例子中,在函数`inFunc`中依然可以访问`otuFunc`的局部变量`name`.
##### 闭包应用举例:模拟类的私有属性
```
function User(){
    this.name = "javascript";  //公有属性
    var age = 23;    //私有属性
    this.sayAge = function(){
        console.log("my age is " + age);
    }
}

var user = new User();
console.log(user.name);
//"javascript"

// 私有属性不可直接访问
console.log(user.age);
//"undefined"

//但可以通过sayAge访问
user.sayAge();
//"my age is 23"
```
利用闭包的性质，局部变量只有在 sayAge 方法中才可以访问，而 name 在外部也访问，从而实现了类的私有属性,这就是闭包在实际开发的其中一个很常见应用。

#### 三、关于delete 操作符，以下代码将输出什么？
```
var x = 1;
var output = (function(){
    delete x;
    return x;
})();

console.log(output);
```
 delete 操作符是将 object 对象的属性删去的操作。但是这里的 x 是并不是对象的属性，  delete 操作符并不能起到作用，所以打印的出的结果仍然是 x 的值。故结果仍然是`1`.

 #### 四、以下代码将输出的结果是什么？
 ```
 var x = { foo : 1};
var output = (function(){
    delete x.foo;
    return x.foo;
})();

console.log(output);
 ```
 答案是:`undefined`;
 >  x 虽然是全局变量，但是它是一个`object`。 `delete`作用在`x.foo`上，成功的将`x.foo`删去。所以返回`undefined`. 

 #### 五、以下代码将输出的结果是什么?
 ```
 var name = 'World!';
(function () {
    if (typeof name === 'undefined') {
        var name = 'Jack';
        console.log('Goodbye ' + name);
    } else {
        console.log('Hello ' + name);
    }
})();
 ```
 > 首先虽然全局声明了`name = 'world'`,但是在函数体内部也有声明`var name`,所以在函数体内部访问`name`时不会访问到外部的`name`,然后函数体内部执行之前先进行函数提升,将`var name`提升到函数的最顶部,载执行`if`语句,此时`name`并没有被赋值,即此时`name = undefined`,所以`typeof name === 'undefined'`为`true`,然后`name`被赋值为`jack`,最后控制台打印结果为:`'Goodbye Jack'`;

 #### 六、以下代码将输出的结果是什么？
 ```
 ["1", "2", "3"].map(parseInt);
 ```
 这道题的正确是答案是:`[1,NaN,NaN]`。
首先，`map()`方法返回一个新数组，数组中的元素为原始数组元素调用函数处理的后值。也就是`map`会把数组`["1", "2", "3"]`遍历一遍，并传入parseInt函数中去进行处理。
`map`给处理函数传的参数不是简单地把数组的每个元素传进去，实际上它会传3个参数`(value,index,array)`。分别是数组的元素，索引和整个数组。
需要注意的是：在这里,`parseInt(value,index,array)`接收了三个参数，实际起作用的只有前2个。
实际上是`parseInt('1',0)`和`parseInt('2',1)`和`parseInt('3',2)`;得到的结果是`[1,NaN,NaN]`。
因为第二个参数作为解析的数字的基数,`parseInt`将第二个参数是作为进制数去处理第一个参数,该值介于`2 ~ 36`之间，如果参数为`0`或者不传，则数字将以`10`为基础来解析。所以第一次遍历得到`1`，如果该参数小于`2`或者大于`36`，则`parseInt()`将返回`NaN`,第三个值为`NaN`的原因是相当于执行了`parseInt("3","2")`，而`2`进制下数字`3`是不存在的，也返回了`NaN`,所以基数(进制数)不能小于第一位参数,否则都会返回`NaN`.

#### 七、以下代码将输出的结果是什么？
```
[typeof null, null instanceof Object]
```
正确的答案是:`["object",false]`
其实`null`不是一个空引用, 而是一个原始值。`null `是表示缺少的标识，指示变量未指向任何对象。把 `null `作为尚未创建的对象（空对象），也许更好理解。
`typeof null`结果是`object`, 这是个历史遗留`bug`,在`ECMA6`中, 曾经有提案为历史平反, 将`type null`的值纠正为`null`, 但最后提案被拒了. 理由是历史遗留代码太多, 不想得罪人, 不如继续将错就错当和事佬。
而`instanceof`用于判断一个变量是否某个对象的实例，也就是问我们` null `是不是`Object`的一个实例。
对于`Null`类型的值（只有`null`），规范定义了`typeof null`返回`"object"`这个字符串。但是本质上`Null`和`Object`不是一个数据类型，`null`值并不是以`Object`为原型创建出来的。所以是得到的结果是`false`。

#### 八、以下代码将输出的结果是什么？
```
var a = [0];
if ([0]) {
    console.log(a == true);
} else {
    console.log("wut");
}
```
在进行`if`判断的时候只有以下几种情况会返回`false`:
1.`""`空的字符串
2.为`0`的数字
3.`undefined`
4.`null`
5.`false`本身

其余的情况都会都会返回`true`
综上所述，`if`语句为真，所以将执行`console.log(a == true)`这个语句
在执行这个语句的时候由于类型不一样，所以会先转换类型
首先会去调用数组的`toString`方法，将`a`转换成字符串，结婚为：`"0"`
由于`"0"`是字符串，所以还得转换成数字，调用`Number("0")` 得到的结果是` 0  `
我们上面说了，数字`0`是`false`，所以`false == true `不成立，结果为`false`

解析为一行代码就是：`console.log(Number(a.toString()) == true)`
执行结果：`console.log(false == true) `输出`false`.

#### 九、以下代码将输出的结果是什么？
```
(function(){
    var x = y = 1;
})();
console.log(y);
console.log(x);
```
这个题目是变量提升和连等赋值问题，首先连等操作符是从右向左赋值的，`y = 1; var x = y; `变量`x`是用`var`进行声明并赋值的所以是局部变量, 变量`y`是未用`var`声明的变量在`javscritp`中是一个隐式全局变量。所以在外面`consoloe.log(y) `是`1`， `console.log(x)` 报错` x is no defined`.

#### 十、以下代码将输出的结果是什么？
```
var a = [1, 2, 3],
    b = [1, 2, 3],
    c = [1, 2, 4];
console.log(a == b);
console.log(a === b);
console.log(a > c);
console.log(a < c);
```
1.对于`console.log(a=b)`;因为`a`和`b`都是数组，是`object`类型，`object`类型在进行`=`比较的时候，比较的对象的引用地址是否相同，很明显，`a`和`b`不是同一个对象，所以引用地址不同，故返回`false`;
2.对于`console.log(a===b)`;`===`运算符要求两边值和数据类型都要相同，`a`和`b`的数据类型都是`object/Array`,但是由于上面的分析可知，`a`和`b`的值并不相同，所以也是返回`false`.
3.对于`console.log(a>c)`;数组进行`>`或者`<`运算比较的时候，首先要调用`valueOf()`方法进行转换成基本类型的值，因为`valueOf()`方法返回的仍然是数组，所以要继续调用`toString()`方法进行转换，返回值为数组元素用逗号连接的字符串，是基本类型的值可以用于比较，所以`console.log(a>c)`等价于`console.log(a.toString()>c.toString())`等价于`console.log("1,2,3">"1,2,4")`相当于是两个字符串在比较大小，而字符串比较大小的时候，是字符串从左到右依次转换成`ASII`码进行比较，前面`1,2,`相同所以实际上是比较`3`和`4`的`ASII`码值的大小，很明显`3`的`ASII`码比`4`的`ASII`码小，所以返回`false`.
4.对于`console.log(a<c)`同3分析，故返回`true`.